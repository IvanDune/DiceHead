* [x] Resttemplate
      не подходит под реактивную архитектуру; плохо масштабируется
      Изучить **WebClient** - новая версия 
* [x] Eventual Consistency, latency, Saga Pattern, circuit breaker, API Gateway
* [x] @LoadBalance
* [x] Mapper
* [ ] @OneToMany
* [x] openApiModel\openApiEndpoint
* [ ] log\ Slf4j
* [x] @Transactional
* [ ] RedisTemplate
* [ ] PostgreSQL
* [ ] Поднятие Docker 
* [ ] DTO
* [ ] Lombok
* [ ] Autowired/Constructor 
* [ ] Git, работа с ветками в нем 
* [ ] ResponceEntity 
* [ ] Interception 
* [ ] OpenFeign
* [ ] Stream
* [ ] kafka
* [ ] UNIT тесты
* [ ] Реализовать equals и hashcode
* [ ] Git

# Лор
#resttemplate
RestTemplate — это синхронный HTTP-клиент Spring для работы с REST-сервисами. Чаще всего используется для интеграций между микросервисами и внешними API. Сейчас находится в maintenance-режиме, но широко применяется в существующих коммерческих проектах. Для сложных сценариев используется метод `exchange()` с кастомной обработкой ошибок и интерсепторами.

#архитектура #микросервисы
Микросервис — это независимо развёртываемый компонент, реализующий один бизнес-контекст, со своей моделью данных и ответственностью.
Для каждого сервиса используется своя схема базы, хотя может быть развернута внутри PostgreSQL
Микросервисы дают независимость и масштабируемость, но усложняют систему. В проде важно использовать таймауты, circuit breaker’ы и событийное взаимодействие, иначе система становится нестабильной.
#архитектура #микросервисы
**Eventual Consistency** -  Система не обязана быть консистентной (целостной в данных, работе) в каждый момент времени,  но при отсутствии новых изменений она придёт к консистентному состоянию.
Eventual consistency — это не «всё асинхронно»,  
это **отказ от глобального ожидания ради устойчивости**.
**API Gatewat** - единая точка входа для клиента в микросервисы. Уменьшает сложность, но увеличивает шанс падения.
**Circuit Breaker** - следит за каскадным падением сервисов и перезапускает их, закрывает поток запросов.
**Saga Pattern** - оркестрация запросов, уход от атомарности
Атомарность (целостное выполнение или не выполнение операции). 
Есть **Choreography Saga** (нет координатора, сервисы сами ловят запросы) и **Orchestration** Saga (координатор руководит шагами)
```
API Gateway 
   ↓
REST / Events
   ↓
Latency → Timeouts → Circuit Breaker
   ↓
Eventual Consistency
   ↓
Saga Pattern
```

#responce_entity 
**ResponseEntity** позволяет явно управлять HTTP-ответом: статусом, заголовками и телом. Используется в контроллерах и обработчиках ошибок для формирования корректного REST-контракта и гибкой реакции на бизнес-сценарии.
```
@ControllerAdvice
@Slf4j
public class GlobalExceptionHandler {
    @ExceptionHandler
    public ResponseEntity<AppError> catchResourceNotFoundException(ResourceNotFoundException e) {
        log.error(e.getMessage(), e);
        return new ResponseEntity<>(new AppError(HttpStatus.NOT_FOUND.value(), e.getMessage()), HttpStatus.NOT_FOUND);
    }
 }
\\\\\\\\\\\\\\\\\\\\\\\\\
return new ResponseEntity<>(HttpStatus.NOT_FOUND);
```
#mapper 
Мы используем Mapstruct и lombok, чтобы упрощать написание классов и конвертацию экземпляра из одного класса в другой. Так из Entity можно получить DTO. В случае, если у нас есть вложенные элементы используется 
```
@Mapping(source = "author.id", target = "authorId")



Сам маппер может выглядеть так 

@Mapper(componentModel = MappingConstants.ComponentModel.SPRING)
public interface UserMapper {    
		UserResponse toUserResponse(User user); //map User to UserResponse 
		List<UserResponse> toUserResponseList(List<User> users); //map list of User to list of UserResponse
	}
```
Над самим классом используется аннотация @Mapper(componentModel = "spring")
#log
Стандартная реализация Java в логах - это @Slf4j + Logback


```
            ┌───────────────┐
            │   Client      │
            └───────┬───────┘
                    │
             ┌──────▼──────┐
             │ API Gateway │
             └──────┬──────┘
        ┌───────────┼────────────┐
        │           │            │
┌───────▼──────┐ ┌──▼────────┐ ┌─▼──────────┐
│ Auth Service │ │ Post Svc   │ │ User Svc   │
└──────────────┘ └────┬───────┘ └────┬───────┘
                       │              │
                ┌──────▼──────┐       │
                │ PostgreSQL  │       │
                │  (Posts)    │       │
                └──────┬──────┘       │
                       │              │
                   ┌───▼───┐          │
                   │ Kafka │◄─────────┘
                   └───┬───┘
                       │
               ┌───────▼────────┐
               │ Feed Service   │
               └───────┬────────┘
                       │
              ┌────────▼─────────┐
              │ Redis / Cassandra│
              │    (Feeds)       │
              └──────────────────┘

```

#бд
Шардирование - расположение репликаций БД в разных сервисах. 
PostgreSQL имеет бесплатную лицензию в отличии от MSSQL, кроссплатформенная, а не только под Windows, легче реплицировать, и в клауде работать.

**Lost Update** (Read uncommited) - решается в большей части современных БД. При откате одной транзакции, откатятся и изменения второй, которая шла параллельно.
**Dirty Read** (Read commit) - транзакция первая изменяет значения, но падает. Вторая считывает измененное значение до падения и работает с ней.
**Non-repeated read** (Repeated read)- в момент долгого выполнения первой транзакции, вторая успевает изменить данные, из-за чего работа первой также меняется. ЧАСТО ВСТРЕЧАЕТСЯ 
**Phantom read** ()- первая транзакция берет данные, вторая изменяет (удаляет) их, из-за чего работа в первое падает.

ACID — это набор фундаментальных свойств (Атомарность, Согласованность, Изолированность, Долговечность), обеспечивающих надежность и целостность транзакций в реляционных базах данных. Они гарантируют корректность данных при сбоях, ошибках или одновременных операциях, предотвращая их повреждение. 

- **[Атомарность](https://www.google.com/search?q=%D0%90%D1%82%D0%BE%D0%BC%D0%B0%D1%80%D0%BD%D0%BE%D1%81%D1%82%D1%8C&oq=ACID&gs_lcrp=EgZjaHJvbWUqBwgAEAAYjwIyBwgAEAAYjwIyDAgBEEUYORixAxiABDIHCAIQABiABDIHCAMQABiABDIHCAQQABiABDIHCAUQABiABDIHCAYQABiABDIGCAcQRRg90gEHOTE5ajBqMagCALACAA&sourceid=chrome&ie=UTF-8&ved=2ahUKEwiOpvjir6uSAxUkR_EDHZwiO_4QgK4QegYIAQgAEAY) (Atomicity):** Транзакция выполняется полностью или не выполняется вовсе.
- **[Согласованность](https://www.google.com/search?q=%D0%A1%D0%BE%D0%B3%D0%BB%D0%B0%D1%81%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D1%81%D1%82%D1%8C&oq=ACID&gs_lcrp=EgZjaHJvbWUqBwgAEAAYjwIyBwgAEAAYjwIyDAgBEEUYORixAxiABDIHCAIQABiABDIHCAMQABiABDIHCAQQABiABDIHCAUQABiABDIHCAYQABiABDIGCAcQRRg90gEHOTE5ajBqMagCALACAA&sourceid=chrome&ie=UTF-8&ved=2ahUKEwiOpvjir6uSAxUkR_EDHZwiO_4QgK4QegYIAQgAEAg) (Consistency):** Транзакция переводит БД из одного корректного состояния в другое.
- **[Изолированность](https://www.google.com/search?q=%D0%98%D0%B7%D0%BE%D0%BB%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D1%81%D1%82%D1%8C&oq=ACID&gs_lcrp=EgZjaHJvbWUqBwgAEAAYjwIyBwgAEAAYjwIyDAgBEEUYORixAxiABDIHCAIQABiABDIHCAMQABiABDIHCAQQABiABDIHCAUQABiABDIHCAYQABiABDIGCAcQRRg90gEHOTE5ajBqMagCALACAA&sourceid=chrome&ie=UTF-8&ved=2ahUKEwiOpvjir6uSAxUkR_EDHZwiO_4QgK4QegYIAQgAEAo) (Isolation):** Параллельные транзакции не влияют друг на друга.
- **[Долговечность](https://www.google.com/search?q=%D0%94%D0%BE%D0%BB%D0%B3%D0%BE%D0%B2%D0%B5%D1%87%D0%BD%D0%BE%D1%81%D1%82%D1%8C&oq=ACID&gs_lcrp=EgZjaHJvbWUqBwgAEAAYjwIyBwgAEAAYjwIyDAgBEEUYORixAxiABDIHCAIQABiABDIHCAMQABiABDIHCAQQABiABDIHCAUQABiABDIHCAYQABiABDIGCAcQRRg90gEHOTE5ajBqMagCALACAA&sourceid=chrome&ie=UTF-8&ved=2ahUKEwiOpvjir6uSAxUkR_EDHZwiO_4QgK4QegYIAQgAEAw) (Durability):** Успешно завершенная транзакция сохраняется даже при сбое питания.
#архитектура #паттерны
1. **Retries** - При провальном обращении к сервису со стороны клиента, мы не возвращаем отказ или ошибку, а повторяем запрос N раз. Мы можем задавать частоту запросов в количестве запросов (отправлять подряд Н запросов до удачного), либо поставить ожидание (между каждым запросом N секунд)
2. **Deadlines** - у нас есть ожидаемое время в ms на обработку запроса. Так, если обращение к сервису выходит за рамки, то мы обрываем запрос и повторяем его еще. Без подобного паттерна мы могли бы получить 3000 ms ожидания и отказ системы. Сейчас, если запрос переваливает, к примеру, за N (100 ms) он отключается.
3. **Rate Burst** - из-за нагрузки в секунду RPS сервис может не справляться с новыми запросами. Появление циклических вызовов, Ddos атаки и т.д. Есть вариант обрезать жестко нагрузку Burst, выше которой не будет обрабатываться вообще. Однако можно создать паттерн Rate Burst. Мы имеем гибкую структуру нижней планки (не 100 RPS, а 1000 запросов за 10 секунд), а также верхнюю планку Burst, которая жестко отсекает выделяющиеся вещи.
4. Circuit Breaker - может произойти всплеск ошибок, из-за которых сервис ляжет. Остальные запросы не будут ему давать возможности "оправиться". Данный паттерн позволяет работать как "рубильник", отключая неработающий сервис и перезапуская его. Трафик/определенные ожидания 
5. Rich Client - сложная логика в сервисе, к которому многие обращаются, к примеру A/B сервис. Не справляется с нагрузкой - падает. Проблема в распределении пользователей на цвет кнопки, к примеру. Мы отправляем часть кода другим клиентам и кэш с распределением. Так логика в AB переходит как в BD, так и асинхронна обратно в сервис вызова. В этом случае при падении первого, данные сохраняются.
#unit 
```
@BeforeEach
void setUp(){

}
```

Используем @ExtendWith(MockitoExtension.class) - для добавления мокита в тест класс
@InjectMock - на главного, @Mock - на зависимости

Mockito .verify(класс/репозиторий, Mockito.times(количество вызовов)).метод_класса