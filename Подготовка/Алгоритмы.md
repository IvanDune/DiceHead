-# Два числа сумма
``` java 
public int[] twoSum(int[] nums, int target) {
    Map<Integer, Integer> map = new HashMap<>();
    for (int i = 0; i < nums.length; i++) {
        int complement = target - nums[i];
        if (map.containsKey(complement)) {
            return new int[] { map.get(complement), i };
        }
        map.put(nums[i], i);
    }
    return new int[] {}; // если решения нет
}
```

# Самое частое число в списке
``` java 
public static void main(String[] args) {
        List<Integer> numbers = List.of(1, 2, 2, 3, 3, 3, 4, 4);

        Integer mostFrequent = numbers.stream()
            .collect(Collectors.groupingBy(
                n -> n,                    // группировка по числу
                Collectors.counting()     // подсчет количества повторений
            ))
            .entrySet().stream()
            .max(Map.Entry.comparingByValue())  // выбираем максимум по количеству
            .map(Map.Entry::getKey)             // извлекаем ключ (само число)
            .orElse(null);                      // если список пуст — null

        System.out.println("Самое частое число: " + mostFrequent);
    }
```
# Объединение двух отсортированных списков кусочных функций
``` java
Arrays.sort(list1, (a, b) -> Integer.compare(a[0],b[0]));
```

``` java 

public static List<int[]> mergeSortedIntervals(List<int[]> list1, List<int[]> list2) {
        List<int[]> combined = new ArrayList<>();
        int i = 0, j = 0;

        // Шаг 1: Объединение двух отсортированных списков
        while (i < list1.size() && j < list2.size()) {
            if (list1.get(i)[0] <= list2.get(j)[0]) {
                combined.add(list1.get(i++));
            } else {
                combined.add(list2.get(j++));
            }
        }
        while (i < list1.size()) combined.add(list1.get(i++));
        while (j < list2.size()) combined.add(list2.get(j++));

        // Шаг 2: Объединение перекрывающихся отрезков
        List<int[]> result = new ArrayList<>();
        for (int[] interval : combined) {
            if (result.isEmpty() || result.get(result.size() - 1)[1] < interval[0]) {
                result.add(interval);
            } else {
                result.get(result.size() - 1)[1] = Math.max(result.get(result.size() - 1)[1], interval[1]);
            }
        }

        return result;
    }
}
```

# Изменение последовательности в списке
## Однонаправленный список
``` java
class ListNode {
	int val;
	ListNode next;
	ListNode(int val){
		this.val = val;
	}
}

public class Solution{
	public ListNode reverseList(ListNode head){
		ListNode prev = null;
		ListNode current = head;
		while (current != null){
			ListNode next = head.next;
			head.next = prev;
			prev = current;
			current = next;
		}
		return prev;
	}
}
```
## Двунаправленный список
``` java 
class DoubleListNode {
	int val;
	DoubleListNode next;
	DoubleListNode prev;
	DoubleListNode(int val){
		this.val = val;
	}
}

public class Solution{
	public DoubleListNode reverseList(DoubleListNode head){
		DoubleListNode prev = null;
		DoubleListNode current = head;
		DoubleListNode temp = null;
		while (current != null){
			temp = current.next;
			current.next = current.prev;
			current.prev = temp;
		}
		if (temp != null){
			head = temp.prev;
		}
		return prev;
	}
}
```

# Сортировка слиянием
``` java 
public static void mergeSort(int[] array){
	int mid = array.length / 2;
	int[] left = new int[mid];
	int[] right = new int[array.length - mid];
	for (int i = 0; i < mid; i++){
		left[i] = array[i];
	}
	for (int j = mid; j < array.length; j++){
		right[j - mid] = array[j];
	}
	mergeSort(left);
	mergeSort(right);
	merge(array, left, right);
}

public static boid merge(int[] array, int[] left, int[] right){
	int i = 0, j = 0, k = 0;
	while(i <= left.length && j <= right.length){
		if(left[i] <= right[j]){
			array[k++] = left[i++];
		} else {
			array[k++] = right[j++];	
		}
	}
	while (i <= left.length){
		array[k++] = left[i++];
	}
	while (j <= right.length){
		array[k++] = right[j++];
	}
}
```

| Характеристика           | **QuickSort**                 | **MergeSort**                         |
| ------------------------ | ----------------------------- | ------------------------------------- |
| **Среднее время**        | `O(n log n)`                  | `O(n log n)`                          |
| **Худшее время**         | `O(n²)`                       | `O(n log n)`                          |
| **Память (доп. память)** | `O(log n)` (рекурсивный стек) | `O(n)` (дополнительный массив)        |
| **Стабильность**         | ❌ Не стабильный               | ✅ Стабильный                          |
| **In-place?**            | ✅ Да (без доп. массивов)      | ❌ Нет (требуется доп. память)         |
| **Скорость на практике** | Обычно быстрее                | Медленнее, особенно на больших данных |
| **Параллелизация**       | Труднее (из-за in-place)      | Легче распараллеливать                |
# Быстрая сортировка 
``` java 
import java.util.Arrays;

public class QuickSortExample {

    public static void quickSort(int[] arr, int low, int high) {
        if (low < high) {
            // Получаем индекс опорного элемента после разделения
            int pivotIndex = partition(arr, low, high);

            // Рекурсивно сортируем левую и правую части
            quickSort(arr, low, pivotIndex - 1);
            quickSort(arr, pivotIndex, high);
        }
    }

    // Метод для разбиения массива и возврата индекса опорного элемента
    private static int partition(int[] arr, int low, int high) {
        int right = high; // Правый индекс
        int left = low;   // Левый индекс
        
        int pivot = arr[low + (hight - low) / 2];

        while (left<=right){ // Пока левый левее правого
	        while(arr[left] < pivot){ // Ищем элемент больше середины
		        left++;
	        }
	        while(arr[right] > pivot){ // Ищем элемент меньше середины
		        right--;
	        }
	        
	        if (left<=right){ // Если индексы не перешли друг друга
		        swap(arr, left, right); // Меняем местами
		        left++;
		        right--
	        }
        
        }

        return left;
    }

    private static void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }

    // Пример использования
    public static void main(String[] args) {
        int[] arr = {8, 4, 7, 3, 10, 2, 5};
        System.out.println("До сортировки: " + Arrays.toString(arr));

        quickSort(arr, 0, arr.length - 1);

        System.out.println("После сортировки: " + Arrays.toString(arr));
    }
}
```
# Задача о рюкзаке
``` java
public static int backppackCount(int[] value, int[] weight, int W, int n) {  
  // value - список ценности, weight - список веса, W - ограничение по весу, n - количество предметов  
  int[][] count = new int[n + 1][W + 1];  
  // количество рассмотренных предметов  
  for (int itemUsed = 1; itemUsed <= value.length; itemUsed++) {  
    int currentObjWeight = weight[itemUsed - 1]; // Вес текущего предмета  
    int currentObjValues = value[itemUsed - 1]; // Ценность текущего предмета  
    // Все возможные ограничения по весу    
    for (int capacity = 0; capacity <= W; capacity++){  
      int valueWithoutItem = count[itemUsed-1][capacity]; // Если не берем предмет, сохраняем предыдущее  
      int valueWithItem = 0; // Базово, если берем предмет  
      if (currentObjWeight<=capacity){  
        valueWithItem = currentObjValues + count[itemUsed - 1][capacity - currentObjWeight];  
      }  
      count[itemUsed][capacity] = Math.max(valueWithoutItem,valueWithItem); // Наилучший вариант  
    }  
  }  
  return count[n][W];  
}
```

# Обход в глубину 
``` java
public static void dfs(int node , boolean[] visited, List<List<Integer>> graph){
	visited[node] = true;
	System.out.printLn(node + " ");
	for(neighbor : graph.get(node)){
		if (!visited[neighbor]){
			dfs(neighbot, visited, graph);
		}
	}
}
```

# Обход в глубину и ширину
``` java 
import java.util.*;  
  
public class GraphTraversal {  
  
// Граф представлен в виде списка смежности  
private Map<Integer, List<Integer» adjList = new HashMap<>();  
  
// Добавление ребра в граф  
public void addEdge(int u, int v) {  
adjList.putIfAbsent(u, new ArrayList<>());  
adjList.putIfAbsent(v, new ArrayList<>());  
adjList.get(u).add(v);  
adjList.get(v).add(u); // если граф ориентированный, эту строку убрать  
}  
  
// Обход в глубину (рекурсивный DFS)  
public void dfs(int start, Set<Integer> visited) {  
	visited.add(start);  
	System.out.print(start + " ");  
  
	for (int neighbor : adjList.getOrDefault(start, Collections.emptyList())) { 
		if (!visited.contains(neighbor)) {  
			dfs(neighbor, visited);  
		}  
	}  
}  
  
// Обход в ширину (BFS)  
public void bfs(int start) {  
	Set<Integer> visited = new HashSet<>();  
	Queue<Integer> queue = new LinkedList<>();  
  
	visited.add(start);  
	queue.add(start);  
  
	while (!queue.isEmpty()) {  
		int node = queue.poll();  
		System.out.print(node + " ");  
  
		for (int neighbor : adjList.getOrDefault(node, Collections.emptyList())) {  
			if (!visited.contains(neighbor)) {  
				visited.add(neighbor);  
				queue.add(neighbor);  
			}  
		}  
	}  
}  
  
public static void main(String[] args) {  
GraphTraversal graph = new GraphTraversal();  
  
// Добавляем рёбра  
graph.addEdge(0, 1);  
graph.addEdge(0, 2);  
graph.addEdge(1, 3);  
graph.addEdge(1, 4);  
graph.addEdge(2, 5);  
  
System.out.print("DFS: ");  
graph.dfs(0, new HashSet<>());  
System.out.println();  
  
System.out.print("BFS: ");  
graph.bfs(0);  
}  
}
```

# Сортировка Map
``` java
Map<String, Integer> sortedByValue = map.entrySet()
    .stream()
    .sorted(Map.Entry.comparingByValue(Comparator.reverseOrder()))
    .limit(k)
    .map(Map.Entry::getValue) // берём только значения
    .collect(Collectors.toMap(
        Map.Entry::getKey,
        Map.Entry::getValue,
        (e1, e2) -> e1,
        LinkedHashMap::new
    ));
```

# Баланс скобок
``` java
public boolean isValid(String s) {  
  Stack<Character> stack = new Stack();  
  for (char c : s.toCharArray()) {  
    switch (c) {  
      case '(' -> stack.push(')');  
      case '[' -> stack.push(']');  
      case '{' -> stack.push('}');  
      default -> {  
        if(stack.isEmpty() || c !=stack.pop()){  
          return false;  
        }  
      }  
    }  
  }  
  if(stack.isEmpty()){  
    return true;  
  } else {  
    return false;  
  }  
}
```
# Полиндром
``` java 
public boolean isPalindrome(String s) {  
  StringBuilder sb = new StringBuilder(s  
          .toLowerCase()  
          .replaceAll("[^a-z0-9]", ""));  
  if (sb.toString().equals(sb.reverse().toString())) {  
    return true;  
  } else {  
    return false;  
  }  
}
```

# Анаграмма
``` java 
public boolean isAnagram(String s, String t) {
    if (s.length() != t.length()) return false;

    Map<Character, Integer> map1 = new HashMap<>();
    Map<Character, Integer> map2 = new HashMap<>();

    for (char c : s.toCharArray()) {
        map1.put(c, map1.getOrDefault(c, 0) + 1);
    }
    for (char c : t.toCharArray()) {
        map2.put(c, map2.getOrDefault(c, 0) + 1);
    }

    return map1.equals(map2);
}

```

# Группировка аннаграм
``` java
public List<List<String>> groupAnagrams(String[] strs) {
    Map<String, List<String>> map = new HashMap<>();

    for (String s : strs) {
        char[] chars = s.toCharArray();
        Arrays.sort(chars);
        String key = new String(chars); // отсортированная строка как ключ
        map.computeIfAbsent(key, k -> new ArrayList<>()).add(s);
    }

    return new ArrayList<>(map.values());
}

```

# Самая длинная строка без повторений
``` java 
public int lengthOfLongestSubstring(String s) {
    Map<Character, Integer> map = new HashMap<>();
    int left = 0, maxLen = 0;

    for (int right = 0; right < s.length(); right++) {
        char c = s.charAt(right);

        // Если символ уже встречался — двигаем левый указатель
        if (map.containsKey(c)) {
            // Только вперёд: чтобы не отступить назад
            left = Math.max(map.get(c) + 1, left);
        }

        map.put(c, right); // обновляем индекс последнего вхождения символа
        maxLen = Math.max(maxLen, right - left + 1);
    }

    return maxLen;
}
```

# Минимальная подстрока со всеми символами списка 
``` java 
public static String minWindow(String s, List<Character> chars) {
    // Шаг 1. Построим карту нужных символов и количества их повторений
    Map<Character, Integer> need = new HashMap<>();
    for (char c : chars) {
        need.put(c, need.getOrDefault(c, 0) + 1);
    }

    // Карта текущего окна: сколько раз каждый символ уже есть в окне
    Map<Character, Integer> window = new HashMap<>();

    // Указатели левого и правого конца окна
    int left = 0, right = 0;

    // Счетчик "валидных" символов — сколько уникальных символов из need мы уже полностью покрыли
    int valid = 0;

    // Для хранения длины и начала минимального окна
    int minLen = Integer.MAX_VALUE;
    int start = 0;

    // Двигаем правый указатель — расширяем окно
    while (right < s.length()) {
        char c = s.charAt(right);
        right++; // расширяем окно

        // Если символ нужен — обновляем window и valid
        if (need.containsKey(c)) {
            window.put(c, window.getOrDefault(c, 0) + 1);
            // Если количество символов в окне теперь совпадает с нужным — увеличиваем valid
            if (window.get(c).intValue() == need.get(c).intValue()) {
                valid++;
            }
        }

        // Если все нужные символы покрыты — пробуем сузить окно
        while (valid == need.size()) {
            // Сохраняем минимальное окно
            if (right - left < minLen) {
                minLen = right - left;
                start = left;
            }

            // Символ, который уходит из окна
            char d = s.charAt(left);
            left++; // сужаем окно

            // Если символ был нужный — уменьшаем счетчики и valid при необходимости
            if (need.containsKey(d)) {
                if (window.get(d).intValue() == need.get(d).intValue()) {
                    valid--; // теряем один валидный символ
                }
                window.put(d, window.get(d) - 1);
            }
        }
    }

    // Если минимальное окно не найдено — возвращаем пустую строку
    return minLen == Integer.MAX_VALUE ? "" : s.substring(start, start + minLen);
}

```
# Наибольший полиндром в строке
``` java 
public class LongestPalindromeFinder {

    // Метод для поиска самого длинного палиндрома
    public static String longestPalindrome(String s) {
        if (s == null || s.length() < 1) return "";

        int start = 0, end = 0;

        // Перебираем все возможные центры палиндромов
        for (int i = 0; i < s.length(); i++) {
            // Палиндром нечетной длины
            int len1 = expandAroundCenter(s, i, i);

            // Палиндром четной длины
            int len2 = expandAroundCenter(s, i, i + 1);

            int len = Math.max(len1, len2);

            // Обновляем границы самого длинного палиндрома
            if (len > end - start) {
                start = i - (len - 1) / 2;  // Вычисляем левую границу
                end = i + len / 2;          // Правую границу
            }
        }

        return s.substring(start, end + 1);
    }

    // Расширяет строку вокруг центра и возвращает длину палиндрома
    private static int expandAroundCenter(String s, int left, int right) {
        while (left >= 0 && right < s.length() && s.charAt(left) == s.charAt(right)) {
            left--;
            right++;
        }

        // После выхода из цикла указатели указывают на символы за границей палиндрома
        return right - left - 1;
    }

    public static void main(String[] args) {
        String input = "babad";
        String result = longestPalindrome(input);
        System.out.println("Longest palindrome: " + result);
    }
}

```

# Развернуть односвязный список 
``` java
public class Main {
    public static void main(String[] args) {
        SingleLinkList<Contact> contactList = new SingleLinkList<>();

        contactList.addToEnd(new Contact(123, "Васильев Евстахий Борисович", "+129381832"));
        contactList.addToEnd(new Contact(151, "Коновалов Степан Петрович", "+234432334"));
        contactList.addToEnd(new Contact(332, "Калинин Артём Валериевич", "+2234234423"));
        contactList.addToEnd(new Contact(432, "Предыбайло Григорий Анатолиевич", "+2342344234"));
        contactList.addToEnd(new Contact(556, "Степанов Мирослав Андреевич", "+6678877777"));

        for(Contact contact: contactList) {
            System.out.println(contact);
        }

        contactList.reverse();

        System.out.println("------------------------");

        for(Contact contact: contactList) {
            System.out.println(contact);
        }
    }

    static class Contact {
        int id;
        String name;
        String phone;

        public Contact(int id, String name, String phone) {
            this.id = id;
            this.name = name;
            this.phone = phone;
        }

        @Override
        public String toString() {
            return "Contact{" +
                    "id=" + id +
                    ", name='" + name + '\'' +
                    ", phone='" + phone + '\'' +
                    '}';
        }
    }

    public static class SingleLinkList<T> implements Iterable<T> {

        ListItem<T> head;
        ListItem<T> tail;

        @Override
        public Iterator<T> iterator() {
            return new Iterator<T>() {
                ListItem<T> current = head;

                @Override
                public boolean hasNext() {
                    return current != null;
                }

                @Override
                public T next() {
                    T data = current.data;
                    current = current.next;
                    return data;
                }
            };
        }

        private static class ListItem<T> {
            T data;
            ListItem<T> next;
        }

        public boolean isEmpty() {
            return head == null;
        }

        public void addToEnd(T item) {
            ListItem<T> newItem = new ListItem<>();
            newItem.data = item;
            if (isEmpty()) {
                head = newItem;
                tail = newItem;
            } else {
                tail.next = newItem;
                tail = newItem;
            }
        }

        public void reverse() {
            if (!isEmpty() && head.next != null) {
                tail = head;
                ListItem<T> current = head.next;
                head.next = null;
                while (current != null) {
                    ListItem<T> next = current.next;
                    current.next = head;
                    head = current;
                    current = next;
                }
            }
        }
    }
}
```





Сортировка встроенная [[Алгоритмы#Быстрая сортировка|Быстрая Сортировка]]
``` java 
List<T> list = new ArrayList<>(List.of(...));
list.sort(Comparator.naturalOrder()); 
list.sort(Comparator.reversedOrder());
Collections.sort(list);

int[] numbers = {...};
Arrays.sort(numbers);
```


# Вернуть все триплеты, которые выдают заданную сумму
``` java
public static List<Integer[]> sumThree(int[] numbers){  
	Arrays.sort(numbers);  // Сортируем массив
	List<List<Integer>> result = new ArrayList<>();  
	int left = 0;  
	int right = numbers.length-1;  
	int center;  
	while (left + 1 <= right){  // левый не пересечется с правым
	  center = left + 1;  
	  right = numbers.length-1;  
	  while (center < right){  // Если сумма 0, то сохраняем, если нет, то двигаем центр
	    int currentSum = numbers[left] + numbers[center] + numbers[right];  
	    if (currentSum == 0){  
	      List<Integer> num = List.of(numbers[left], numbers[center], numbers[right]);  
	      result.add(num);  
	      do{  
	        center++;  // Сдвигаем пока не перестанут повторяться
	      }while(center < numbers.length && numbers[center] == numbers[center-1]);  
	    } else if (currentSum > 0){  // Если сумма больше 0, то двигаем правый
	      right--;  
	    } else{  
	      do{  
	        center++;  // Сдвигаем пока не перестанут повторяться
	      }while(center < numbers.length && numbers[center] == numbers[center-1]);  
	    }  
	  }  
	  do{  
	    left++;  // Сдвигаем пока не перестанут повторяться
	  }while(left < numbers.length && numbers[left] == numbers[left-1]);  
	}  
	return result;
}
```

# Сумма двух развернутых списков
Есть два односвязных списка, каждый из которых содержит число. В каждой ноде цифра этого числа, начиная с последнего. Нужно вернуть список их суммы. [LeetCode](https://leetcode.com/problems/add-two-numbers/description/)

ЕСТЬ ПРОБЛЕМА. Два массива 0 и 0 не отрабатывают и зацикливаются 

``` java
static ListNode supp(ListNode l1, ListNode l2, ListNode prev, int help) {  
  int sum = l1.val + l2.val + help;  
  ListNode result = new ListNode();  
  if (prev == null) {  
    prev = result;  
  }  
  if (sum < 9) {  
    result.val = sum;  
    prev.next = result;  
    help = 0;  
  } else {  
    result.val = sum % 10;  
    help = sum / 10;   
  }  
  if (l1.next != null && l2.next != null) {  
    supp(l1.next, l2.next, result, help);  
  } else if (l1.next != null) {  
    supp(l1.next, new ListNode(0), result, help);  
  } else if (l2.next != null) {  
    supp(new ListNode(0), l2.next, result, help);  
  } else {  
    if (help != 0){  
      ListNode temp = new ListNode(help);  
      result.next = temp;  
    }  else  
	if (prev == result){  
	  result.next = null;  
	}
    return result;  
  }  
  return result;  
  
}  
  
public static ListNode addTwoNumbers(ListNode l1, ListNode l2) {  
  return supp(l1, l2, null, 0);  
}
```