Есть ли смысл ставить syncronyzed на метод с Аннотацией @Transactional?
Реализовать задачу о банкомате. Интерпретировать ее на многопоточку
`Нужно реализовать работу банкомата. У него есть бакеты, в которых он хранит купюры разного наминала: 10, 50, 100, 200, 500, 1000, 5000 рублей. Фиксируется количество купюр каждого наминала. Есть два метода положить купюры на счет, выдать фиксированную сумму, стараться выдавать более крупными купюроами сумму. В ином случае переходить на более мелкие. Если выдать указанную сумму не возможно, нет подходящего количества купюр в банкомате, то выдать сообщение об этом.`

`Теперь представим, что это не физический банкомат, а взаимодействие со счетом, куда множество пользователей может класть деньги и снимать. Предполагается высокая нагрузка с взаимодействием счета. Что стоит добавить к существующей реализации, чтобы она работала асинхронно, была потокозащищенной и выдерживала RPS 10k+?`
## Caffein

## RPS и Высоконагруженные тесты
Request per Second - при повышении нагрузки мы отказываемся от использовании БД на критическом уровне, переходим на асинхронный формат. Добавляем Redis для хранения данных, INCR для изменения значений, добавляем очередь из запросов (Kafka).

Может быть выше задержка, но система выдерживает нагрузку
``` java
redisTemplate.opsForValue().increment(key) // Инкрементируем значение
```
## ExceptionHandler
``` java 
// Исключение
public class ResourceNotFoundException extends RuntimeException {

    public ResourceNotFoundException(String message) {
        super(message);
    }
}
```

``` java
// Обработка исключения
@ControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(ResourceNotFoundException.class)
    public ResponseEntity<Object> handleResourceNotFound(ResourceNotFoundException ex) {
        Map<String, Object> body = new HashMap<>();
        body.put("timestamp", LocalDateTime.now());
        body.put("message", ex.getMessage());
        body.put("status", HttpStatus.NOT_FOUND.value());

        return new ResponseEntity<>(body, HttpStatus.NOT_FOUND);
    }

    // Можно добавить и другие обработчики, например:
    @ExceptionHandler(Exception.class)
    public ResponseEntity<Object> handleGeneral(Exception ex) {
        Map<String, Object> body = new HashMap<>();
        body.put("timestamp", LocalDateTime.now());
        body.put("message", "Internal error: " + ex.getMessage());
        body.put("status", HttpStatus.INTERNAL_SERVER_ERROR.value());

        return new ResponseEntity<>(body, HttpStatus.INTERNAL_SERVER_ERROR);
    }
}
```

``` java
//Вызов обработчика
@GetMapping("/api/video/{id}")
public ResponseEntity<Video> getVideo(@PathVariable String id) {
    Video video = videoService.findById(id)
        .orElseThrow(() -> new ResourceNotFoundException("Video not found with id: " + id));

    return ResponseEntity.ok(video);
}
```
## ConcurrentHashMap
Потокобезопасная реализация HashMap, высокая производительность нет ключей null, использует compareAndSwap и syncronyzed.

## AtomicInteger
`AtomicInteger` — это класс из пакета `java.util.concurrent.atomic`, предоставляющий потокобезопасные атомарные операции с переменными типа `int` без использования синхронизации (`synchronized`).

| Метод                                 | Описание                                                                                |
| ------------------------------------- | --------------------------------------------------------------------------------------- |
| get()                                 | Возвращает текущее значение                                                             |
| set(int newValue)                     | Устанавливает значение                                                                  |
| incrementAndGet()                     | Увеличивает на 1 и возвращает новое значение                                            |
| getAndIncrement()                     | Возвращает текущее значение, затем увеличивает на 1                                     |
| decrementAndGet()                     | Уменьшает на 1 и возвращает новое значение                                              |
| getAndAdd(int delta)                  | Возвращает текущее значение, затем прибавляет delta                                     |
| compareAndSet(int expect, int update) | Если текущее значение равно `expect`, заменяет его на `update` (CAS — compare-and-swap) |
