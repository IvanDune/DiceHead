# Объединение двух отсортированных списков кусочных функций
``` java 

public static List<int[]> mergeSortedIntervals(List<int[]> list1, List<int[]> list2) {
        List<int[]> combined = new ArrayList<>();
        int i = 0, j = 0;

        // Шаг 1: Объединение двух отсортированных списков
        while (i < list1.size() && j < list2.size()) {
            if (list1.get(i)[0] <= list2.get(j)[0]) {
                combined.add(list1.get(i++));
            } else {
                combined.add(list2.get(j++));
            }
        }
        while (i < list1.size()) combined.add(list1.get(i++));
        while (j < list2.size()) combined.add(list2.get(j++));

        // Шаг 2: Объединение перекрывающихся отрезков
        List<int[]> result = new ArrayList<>();
        for (int[] interval : combined) {
            if (result.isEmpty() || result.get(result.size() - 1)[1] < interval[0]) {
                result.add(interval);
            } else {
                result.get(result.size() - 1)[1] = Math.max(result.get(result.size() - 1)[1], interval[1]);
            }
        }

        return result;
    }
}
```

# Изменение последовательности в списке
## Однонаправленный список
``` java
class ListNode {
	int val;
	ListNode next;
	ListNode(int val){
		this.val = val;
	}
}

public class Solution{
	public ListNode reverseList(ListNode head){
		ListNode prev = null;
		ListNode current = head;
		while (current != null){
			ListNode next = head.next;
			head.next = prev;
			prev = current;
			current = next;
		}
		return prev;
	}
}
```
## Двунаправленный список
``` java 
class DoubleListNode {
	int val;
	DoubleListNode next;
	DoubleListNode prev;
	DoubleListNode(int val){
		this.val = val;
	}
}

public class Solution{
	public DoubleListNode reverseList(DoubleListNode head){
		DoubleListNode prev = null;
		DoubleListNode current = head;
		DoubleListNode temp = null;
		while (current != null){
			temp = current.next;
			current.next = current.prev;
			current.prev = temp;
		}
		if (temp != null){
			head = temp.prev;
		}
		return prev;
	}
}
```
# Обход в глубину 
``` java
public static void dfs(int node , boolean[] visited, List<List<Integer>> graph){
	visited[node] = true;
	System.out.printLn(node + " ");
	for(neighbor : graph.get(node)){
		if (!visited[neighbor]){
			dfs(neighbot, visited, graph);
		}
	}
}
```

# Сортировка слиянием
``` java 
public static void mergeSort(int[] array){
	int mid = array.length / 2;
	int[] left = new int[mid];
	int[] right = new int[array.length - mid];
	for (int i = 0; i < mid; i++){
		left[i] = array[i];
	}
	for (int j = mid; j < array.length; j++){
		right[j - mid] = array[j];
	}
	mergeSort(left);
	mergeSort(right);
	merge(array, left, right);
}

public static boid merge(int[] array, int[] left, int[] right){
	int i = 0, j = 0, k = 0;
	while(i <= left.length && j <= right.length){
	if(left[i] <= right[j]){
		array[k++] = left[i++];
	} else {
		array[k++] = right[j++];	
	}
	}
	while (i <= left.length){
		array[k++] = left[i++];
	}
	while (j <= right.length){
		array[k++] = right[j++];
	}
}
```

# Задача о рюкзаке
``` java
public static int knapsack(int n, int W, int[] weight, int[] value){
int[][] dp = new int[n+1][W+1];
for (int i = 0; i <= n; i++){
	for (int w = 0; w<=W; w++){
		if (i == 0 || w == 0){
			dp[i][w] = 0;
		} else {
			if(weight[i - 1] <= W){
				dp[i][w] = Math.max(dp[i-1][w], value[i-1] + dp[i - 1][W - weight[i - 1]])
			} else {
				dp[i][w] = dp[i-1][w];
			}
		}
	}
}

}
```