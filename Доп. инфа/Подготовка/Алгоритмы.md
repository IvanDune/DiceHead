# Объединение двух отсортированных списков кусочных функций
``` java 

public static List<int[]> mergeSortedIntervals(List<int[]> list1, List<int[]> list2) {
        List<int[]> combined = new ArrayList<>();
        int i = 0, j = 0;

        // Шаг 1: Объединение двух отсортированных списков
        while (i < list1.size() && j < list2.size()) {
            if (list1.get(i)[0] <= list2.get(j)[0]) {
                combined.add(list1.get(i++));
            } else {
                combined.add(list2.get(j++));
            }
        }
        while (i < list1.size()) combined.add(list1.get(i++));
        while (j < list2.size()) combined.add(list2.get(j++));

        // Шаг 2: Объединение перекрывающихся отрезков
        List<int[]> result = new ArrayList<>();
        for (int[] interval : combined) {
            if (result.isEmpty() || result.get(result.size() - 1)[1] < interval[0]) {
                result.add(interval);
            } else {
                result.get(result.size() - 1)[1] = Math.max(result.get(result.size() - 1)[1], interval[1]);
            }
        }

        return result;
    }
}
```

# Изменение последовательности в списке
## Однонаправленный список
``` java
class ListNode {
	int val;
	ListNode next;
	ListNode(int val){
		this.val = val;
	}
}

public class Solution{
	public ListNode reverseList(ListNode head){
		ListNode prev = null;
		ListNode current = head;
		while (current != null){
			ListNode next = head.next;
			head.next = prev;
			prev = current;
			current = next;
		}
		return prev;
	}
}
```
## Двунаправленный список
``` java 
class DoubleListNode {
	int val;
	DoubleListNode next;
	DoubleListNode prev;
	DoubleListNode(int val){
		this.val = val;
	}
}

public class Solution{
	public DoubleListNode reverseList(DoubleListNode head){
		DoubleListNode prev = null;
		DoubleListNode current = head;
		DoubleListNode temp = null;
		while (current != null){
			temp = current.next;
			current.next = current.prev;
			current.prev = temp;
		}
		if (temp != null){
			head = temp.prev;
		}
		return prev;
	}
}
```
# Обход в глубину 
``` java
public static void dfs(int node , boolean[] visited, List<List<Integer>> graph){
	visited[node] = true;
	System.out.printLn(node + " ");
	for(neighbor : graph.get(node)){
		if (!visited[neighbor]){
			dfs(neighbot, visited, graph);
		}
	}
}
```

# Сортировка слиянием
``` java 
public static void mergeSort(int[] array){
	int mid = array.length / 2;
	int[] left = new int[mid];
	int[] right = new int[array.length - mid];
	for (int i = 0; i < mid; i++){
		left[i] = array[i];
	}
	for (int j = mid; j < array.length; j++){
		right[j - mid] = array[j];
	}
	mergeSort(left);
	mergeSort(right);
	merge(array, left, right);
}

public static boid merge(int[] array, int[] left, int[] right){
	int i = 0, j = 0, k = 0;
	while(i <= left.length && j <= right.length){
		if(left[i] <= right[j]){
			array[k++] = left[i++];
		} else {
			array[k++] = right[j++];	
		}
	}
	while (i <= left.length){
		array[k++] = left[i++];
	}
	while (j <= right.length){
		array[k++] = right[j++];
	}
}
```

# Задача о рюкзаке
``` java
public static int knapsack(int n, int W, int[] weight, int[] value){
int[][] dp = new int[n+1][W+1];
for (int i = 0; i <= n; i++){
	for (int w = 0; w <= W; w++){
		if (i == 0 || w == 0){
			dp[i][w] = 0;
		} else {
			if(weight[i - 1] <= W){
				dp[i][w] = Math.max(dp[i-1][w], value[i-1] + dp[i - 1][w - weight[i - 1]])
			} else {
				dp[i][w] = dp[i-1][w];
			}
		}
	}
}

}
```

# Обход в глубину и ширину
``` java 
import java.util.*;  
  
public class GraphTraversal {  
  
// Граф представлен в виде списка смежности  
private Map<Integer, List<Integer» adjList = new HashMap<>();  
  
// Добавление ребра в граф  
public void addEdge(int u, int v) {  
adjList.putIfAbsent(u, new ArrayList<>());  
adjList.putIfAbsent(v, new ArrayList<>());  
adjList.get(u).add(v);  
adjList.get(v).add(u); // если граф ориентированный, эту строку убрать  
}  
  
// Обход в глубину (рекурсивный DFS)  
public void dfs(int start, Set<Integer> visited) {  
	visited.add(start);  
	System.out.print(start + " ");  
  
	for (int neighbor : adjList.getOrDefault(start, Collections.emptyList())) {  
		if (!visited.contains(neighbor)) {  
			dfs(neighbor, visited);  
		}  
	}  
}  
  
// Обход в ширину (BFS)  
public void bfs(int start) {  
	Set<Integer> visited = new HashSet<>();  
	Queue<Integer> queue = new LinkedList<>();  
  
	visited.add(start);  
	queue.add(start);  
  
	while (!queue.isEmpty()) {  
		int node = queue.poll();  
		System.out.print(node + " ");  
  
		for (int neighbor : adjList.getOrDefault(node, Collections.emptyList())) {  
			if (!visited.contains(neighbor)) {  
				visited.add(neighbor);  
				queue.add(neighbor);  
			}  
		}  
	}  
}  
  
public static void main(String[] args) {  
GraphTraversal graph = new GraphTraversal();  
  
// Добавляем рёбра  
graph.addEdge(0, 1);  
graph.addEdge(0, 2);  
graph.addEdge(1, 3);  
graph.addEdge(1, 4);  
graph.addEdge(2, 5);  
  
System.out.print("DFS: ");  
graph.dfs(0, new HashSet<>());  
System.out.println();  
  
System.out.print("BFS: ");  
graph.bfs(0);  
}  
}
```

# Баланс скобок
``` java
public boolean isValid(String s) {  
  Stack<Character> stack = new Stack();  
  for (char c : s.toCharArray()) {  
    switch (c) {  
      case '(' -> stack.push(')');  
      case '[' -> stack.push(']');  
      case '{' -> stack.push('}');  
      default -> {  
        if(stack.isEmpty() || c !=stack.pop()){  
          return false;  
        }  
      }  
    }  
  }  
  if(stack.isEmpty()){  
    return true;  
  } else {  
    return false;  
  }  
}
```
# Полиндром
``` java 
public boolean isPalindrome(String s) {  
  StringBuilder sb = new StringBuilder(s  
          .toLowerCase()  
          .replaceAll("[^a-z0-9]", ""));  
  if (sb.toString().equals(sb.reverse().toString())) {  
    return true;  
  } else {  
    return false;  
  }  
}
```

# Два числа сумма
``` java 
public int[] twoSum(int[] nums, int target) {
    Map<Integer, Integer> map = new HashMap<>();
    for (int i = 0; i < nums.length; i++) {
        int complement = target - nums[i];
        if (map.containsKey(complement)) {
            return new int[] { map.get(complement), i };
        }
        map.put(nums[i], i);
    }
    return new int[] {}; // если решения нет
}
```

# Анаграмма
``` java 
public boolean isAnagram(String s, String t) {
    if (s.length() != t.length()) return false;

    Map<Character, Integer> map1 = new HashMap<>();
    Map<Character, Integer> map2 = new HashMap<>();

    for (char c : s.toCharArray()) {
        map1.put(c, map1.getOrDefault(c, 0) + 1);
    }
    for (char c : t.toCharArray()) {
        map2.put(c, map2.getOrDefault(c, 0) + 1);
    }

    return map1.equals(map2);
}

```

# Сортировка Map
``` java
Map<String, Integer> sortedByValue = map.entrySet()
    .stream()
    .sorted(Map.Entry.comparingByValue(Comparator.reverseOrder()))
    .limit(k)
    .map(Map.Entry::getValue) // берём только значения
    .collect(Collectors.toList());.collect(Collectors.toMap(
        Map.Entry::getKey,
        Map.Entry::getValue,
        (e1, e2) -> e1,
        LinkedHashMap::new
    ));
```

# Группировка аннаграм
``` java
public List<List<String>> groupAnagrams(String[] strs) {
    Map<String, List<String>> map = new HashMap<>();

    for (String s : strs) {
        char[] chars = s.toCharArray();
        Arrays.sort(chars);
        String key = new String(chars); // отсортированная строка как ключ
        map.computeIfAbsent(key, k -> new ArrayList<>()).add(s);
    }

    return new ArrayList<>(map.values());
}

```

# Самая длинная строка без повторений
``` java 
public int lengthOfLongestSubstring(String s) {
    Map<Character, Integer> map = new HashMap<>();
    int left = 0, maxLen = 0;

    for (int right = 0; right < s.length(); right++) {
        char c = s.charAt(right);

        // Если символ уже встречался — двигаем левый указатель
        if (map.containsKey(c)) {
            // Только вперёд: чтобы не отступить назад
            left = Math.max(map.get(c) + 1, left);
        }

        map.put(c, right); // обновляем индекс последнего вхождения символа
        maxLen = Math.max(maxLen, right - left + 1);
    }

    return maxLen;
}
```
