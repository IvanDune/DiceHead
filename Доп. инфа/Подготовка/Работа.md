# Java 
## Аннотации
* Cacheable - сохранение данных в КЭШ (Redis). Альтернатива template.
* Async - вызов асинхронной работы метода (когда не требуется ожидание результата). Не сработает, если вызывается метод внутри класса.

## Типы данных
### String
* toCharArray() - массив символов;
* indexOf() - первый индекс входящий в подстроку;
* replace() - замена в строке подстроку на другую;
* substring() - возвращение с индекса по индекс;
* length() - длинна;
* charAt() - возвращение символа по индексу.

String.valueOf() - преобразование в строку;
Integer.parseInt("") - преобразование строки в int;
StringBuilder:
* append() - добавить элемент;
* deleteCharAt() - удаление символа;
* reverse() - изменение порядка

String.format("... %d", num); Подстановка элементов в строку
%d - целое число;
%f - вещественное число;
%b - boolean;
%t - data;
%s - строка.
### List
```java 
List<String> list = new ArrayList<>();
String[] str = list.toArray();
``` 
### Map
* keySet() - сет ключей;
* entrySet - для Map.Entry<,> entry значения в HashMap;
* values - список значений;
* size() - размер, не length;
* put(key, value) - положить значение;
* containsKey() - есть ли ключ;
* equals() - сравнение коллекций.

Создание Map, где key - символ, value - частота появления в последовательнсти.
Создание Map, где key - значение числа, value - индекс.
# БД
## Транзакции
* READ_UNCOMMITED - ничего не блокирует
* READ_COMMITED - по умолчанию в PostgreSQL нет грязного чтения (неповторяемое)
* REPETEABLE_READ - по умолчанию в MySQL нет грязного/неповторяемого чтения (фантомные чтения)
* SERIALIZABLE - блокирует все (медленно работает)

**Грязное чтение**: Одна транзакция читает незафиксированные данные другой.
**Неповторяемое чтение**: Одна транзакция читает дважды одни и те же строки, потому что вторая транзакция их изменила.
**Фантомное чтение**: Одна отправляет запрос, вторая удаляет или изменяет строки, которые влияют на результат.

## Запросы
1. **SELECT** * FROM table_name WHERE num **BETWEEN** a **AND** b;
2. UPDATE table_name SET name = "name" WHERE id **IN** (SELECT user_id FROM orders WHERE total > 1000);
3. DELETE FROM table_name where id = 12;
4. SELECT city, **COUNT**( * ) as user_count FROM users **GROUP BY** city **HAVING** COUNT( * ) > 18
5. SELECT u.name, o.total FROM users u **INNER JOIN** orders o ON u.id = o.user_id;
# Kafka
Kafka - брокер сообщений, который является "шиной" между пользователями и сервисом, между сервисами. Используется несколько брокеров для отказоустойчивости. Так, при выходе из строя одного, уведомление подхватит другой.
1. Существует множество брокеров, некоторые друг с другом связаны;
2. Каждый брокер имеет топики "темы", куда отправляются сообщения;
3. Топики делятся на партиции, где хранятся сообщении и затем отправляются consumer.

Топики обрабатываются параллельно, партиции последовательно. Можно настроить, что разные партиции одного топика будут находиться в разных брокерах. 

Это уменьшает загруженность и трафик.

Работа происходит также как и в [[#Redis]]. 
Создание Config либо описание в yaml файле application:
``` java
@Configuration
public class KafkaConfig{
@Bean
public ProducerFactory<String, class> producerFactory{
Map<String, Object> conf = new HashMap<>();
conf.put... // Настройка сериализации и десериализации для consumer и producer
}
}
```

Отправка данных kafkaTemplate.send("topic", класс), получение @KafkaListener(topics = "topic")
# Docker

# Spring
## Прокси
Прокси - это объекты-обертки, которые вызываются над стандартными бинами. К ним относятся Transactional, Async, Cacheable и т.д. Прокси не вызывается, если идет вызов метода в методе самого бина.

## Жизненный цикл
1. Создание объекта;
2. Установка зависимостей;
3. Вызов интерфейса Aware, если есть;
4. BeanPostProcessor (до инициализации);
5. BeanFactory;
6. BeanPostProcessor (после инициализации);
7. Использование;
8. Уничтожение.

## BeanScope
Область видимости бина в программе:
* Singlton - один экземпляр на весь Spring;
* Prototype - при каждом новом вызове, создается новый бин;
* Request - для каждого нового Http запроса;
* Session - для каждой новой Http сессии;
* Application - один на СервлектКонтекст;
* Websocket - один на бин websocket.

Используется в программировании как @Scope(" ")
# Многопоточка

# Redis
## Функции
Пример использования внутри:
1. Присвоение значения - SET firstKey "Hello";
2. Просмотр значения - GET firstKey;
3. Удалить значение - DELETE firstKey;
4. Все значения - KEYS * ;
5. Добавить что-то к числу - INCRBY num 3;
6. Работа со списками, добавление элемента - LPUSH/RPUSH cars "Toyota";
7. Все значения в списке по индексу - LRANGE cars 0 - 1;
8. Достает первый элемент из списка - LPOP cars;
9. Длина списка -  LLEN cars;
10. Добавление элемента из списка в список - LMOVE cars sold LEFT LEFT;
11. Сколько времени жизни - TTL;
12. Задается время жизни - EXPIRE sec;

## Основная информация
Редис - это надстройка над БД, NoSql, которая представляет из себя ХЭШ в RAM (оперативной памяти). Она во много раз ускоряет процесс работы с записями. Работает как пара KEY - VALUE.

Redis - скорость, Cassandra - много записей, mongoDB - данные без структуры.
BASE:
* BA - Base Availability. Базовая доступность, всегда есть доступ к данным;
* S - Soft State. Мягкое состояние, могут быть неактуальные данные при перенаправлении на Slave кластер;
* E - Eventual Consistance. Непротеворечивость в конечном итоге, гарантия доставки данных.
## Внутри Java
1. Установка и развертывание Redis (Docker/Сервер);
2. Добавление зависимостей и подгрузка библиотек;
3. Настройка application.yaml;
4. Создание RedisConfig и Bean для настройки RedisTemplate;
5. Работа reditTemplate.set( , ) - положить значение по ключу, reditTemplate.get() - получить значение по ключу.

Можно работать как с RedisTemplate, так и с аннотациями @Cacheable(value = "users", keys = "#id"). Существует Pub/Sub - аналог Kafka.

Создается топик, на который подписывается сервис. При его обновлении отсылается уведомление.
1. Создание RedisPubSubConfig;
2. Используется RedisMessageListenerContainer.
``` java 
listenerContainer.addMessageListener(
(message, pattern) -> {
try{
body = new String(message.body(), StandartCharsets.UTF_8)
}
}
)
```
Это подписка и логика при обработке
Не забывать о @EventListener(ContentRefreshedEvent.class)